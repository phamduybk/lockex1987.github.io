<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>JavaScript Functional Programming</title>
  </head>
  <body>
    <h2>[JavaScript] Functional Programming</h2>
    <p>Lập trình hàm (Functional programming) không còn là cái tên lạ lẫm trong
      thời gian gần đây, nhiều lập trình viên đã và đang dần chuyển đổi theo mô
      hình lập trình này. Trong bài viết hôm nay, chúng ta sẽ cùng nhau tìm hiểu
      cơ bản về lập trình hàm trong JavaScript.</p>
    <h3>Basic example</h3>
    <p>Chúng ta sẽ xem xét một số ví dụ để thấy được một số điểm thú vị của lập
      trình hàm trong JavaScript nhé. Ở đây, mình sẽ sử dụng cú pháp ES6.<a href="https://viblo.asia/s/javascript-es6-WrZngQrnlxw"
        target="_blank"></a></p>
    <p>Trong JavaScript , functions là variables.</p>
    <pre><code>    // functions are variables
    const log = message =&gt; console.log(message) 
</code></pre>
    <p>Vì functions là variables nên chúng ta có thể dễ dàng đưa chúng vào trong
      một đối tượng như sau:</p>
    <pre><code>    // function are variables =&gt; we can add them to objects
    const obj = {
      message: "message",
      log(message) {
        console.log(message)
      }
    }
    obj.log(obj.message) // message
</code></pre>
    <p>Tương tự, chúng ta hoàn toàn có thể đưa chúng vào trong một mảng.</p>
    <pre><code>    // we can add function to arrays
    const arr = ["hello", message =&gt; console.log(message)]
    arr[1](arr[0]) // hello
</code></pre>
    <p>Chúng ta cũng có thể truyền functions vào function khác như một đối số.</p>
    <pre><code>    // we can send functions to other functions as arguments
    const insideFn = logger =&gt; logger("test")
    insideFn(message =&gt; console.log(message)) // test
</code></pre>
    <p>Tương tự, chúng ta sẽ có thể trả về một function trong một function khác.</p>
    <pre><code>    // we can return a function
    const returnFn = () =&gt; log
    returnFn()("return a function") // return a function
    
    const returnFn2 = logger =&gt; message =&gt; logger(message.toUpperCase())
    returnFn2(message =&gt; console.log(message))("Nguyen Thanh Tuan") // NGUYEN THANH TUAN
</code></pre>
    <p>Ở đoạn này <code>const returnFn2 = logger =&gt; message =&gt;
        logger(message.toUpperCase())</code> có thể có nhiều bạn khó hiểu nên
      mình sẽ viết lại theo cú pháp cũ như sau:</p>
    <pre><code>    var returnFn2 = function(logger) {
      return function(message) {
        logger(message.toUpperCase())
      }
    }
    returnFn2(message =&gt; console.log(message))("Nguyen Thanh Tuan") // NGUYEN THANH TUAN
</code></pre>
    <p>Như vậy, qua một số ví dụ trên, chúng ta có thể thấy trong lập trình hàm,
      hàm (function) được sử dụng khá thuận tiện và linh hoạt, các bạn đã thấy
      thú vị hay chưa?</p>
    <h3>Imperative vs Declarative</h3>
    <p>Imperative là một mô hình lập trình quen thuộc với chúng ta, như C, Java,
      ... đều được thiết kế dựa trên mô hình này. Tuy nhiên lập trình hàm không
      nằm trong mô hình này mà nó là một phần của mô hình lập trình Declarative.
      Có nhiều cách để hiểu hai mô hình này mà chúng ta có thể tìm thấy trên
      mạng tuy nhiên mình sẽ nói theo cách hiểu của mình như sau:</p>
    <ul>
      <li>Imperative: nói cho máy tính các bước làm (how) để thực hiện công việc</li>
      <li>Declararive: nói cho máy tính công việc là gì (what)</li>
    </ul>
    <p>Ví dụ chúng ta muốn nối các phần tử của một mảng ngăn cách bởi khoảng
      trắng và tạo thành một chuỗi. Cách làm tương ứng với hai mô hình lập trình
      như sau:</p>
    <pre><code>    const array = ["Hello", "World"]

    // imperative
    let result = ""
    for (let i = 0; i &lt; array.length; i++) {
      result += array[i]
      if (i !== array.length - 1) {
        result += " "
      }
    }
    console.log(result) // Hello World
    
    // declarative
    console.log(array.join(" ")) // Hello World
</code></pre>
    <p>Như vậy, với cách làm theo imperative, chúng ta sẽ phải chỉ ra tuần tự
      các bước để máy tính thực hiện và cho ra kết quả, còn đối với declarative,
      chúng ta chỉ cần chỉ ra công việc là gì và không cần quan tâm máy tính sẽ
      làm như nào để có được kết quả. Hy vọng qua ví dụ nhỏ này, các bạn có thể
      hiểu hơn về hai mô hình lập trình trên.</p>
    <h3>Functional Concepts</h3>
    <p>Tiếp theo, chúng ta sẽ tìm hiểu các concept trong lập trình hàm.</p>
    <h4>Immutability</h4>
    <p>Đầu tiên là immutability - không thay đổi. Điều này có nghĩa là chúng ra
      sẽ hạn chế thay đổi các biến trong chương trình, việc này sẽ giúp khi
      chúng ta debug hoặc maintain chương trình. Ví dụ:</p>
    <pre><code>    let person = {
      name: "Tuan",
      age: 25,
      phone: "0123456789"      
    }
    const changePhone = (person, phone) =&gt; {
      person.phone = phone
      return person
    }
    console.log(changePhone(person, "474747474747").phone) // 474747474747
    console.log(person.phone) // 474747474747
</code></pre>
    <p>Trong JavaScript, đối số của function được trỏ trực tiếp đến dữ liệu
      thật. Do đó khi thay đổi <code>phone</code> của <code>person</code>,
      chúng ta đã thay đổi chính data thực. Để không thay đổi, chúng ta cần tạo
      ra bản sao của <code>person</code>.</p>
    <pre><code>    let person = {
      name: "Tuan",
      age: 25,
      phone: "0123456789"      
    }
    const changePhone = (person, phone) =&gt; Object.assign({}, person, { phone: phone })
    console.log(changePhone(person, "474747474747").phone) // 474747474747
    console.log(person.phone) // 0123456789
</code></pre>
    <p>Ngoài cách trên chúng ta có thể sử dụng cú pháp <code>spread operator</code>.</p>
    <pre><code>    let person = {
      name: "Tuan",
      age: 25,
      phone: "0123456789"      
    }
    const changePhone = (person, phone) =&gt; ({
      ...person,
      phone
    })
    console.log(changePhone(person, "474747474747").phone) // 474747474747
    console.log(person.phone) // 0123456789
</code></pre>
    <p>Để hiểu hơn về immutability, chúng ta sẽ làm thêm một ví dụ khác.</p>
    <pre><code>    let list = [
      {title: "Rad Red"},
      {title: "Lawn"},
      {title: "Party Pink"}
    ]
    var addColor = function(title, colors) {
      colors.push({title})
      return colors
    }
    console.log(addColor("test", list).length) // 4
    console.log(list.length) // 4
</code></pre>
    <p>Các bạn có thể viết thử cách khác để đảm bảo tính immutability của <code>addColor</code>
      xem sao nhé.</p>
    <h4>Pure Functions</h4>
    <p>Pure functions là một function cần được thỏa mãn các điều kiện sau</p>
    <ul>
      <li>Có ít nhất một đối số</li>
      <li>Trả về 1 giá trị hoặc 1 function khác</li>
      <li>Không làm thay đổi đối số hoặc bất kỳ giá trị nào của đối số</li>
    </ul>
    <p>Chúng ta sẽ lấy một ví dụ sau:</p>
    <pre><code>    let me = {
      name: "Thanh Tuan",
      favorite: "Programming"
    }

    // not a pure function
    const changeName = (person, newName) =&gt; {
      person.name = newName
      return person
    }
    console.log(changeName(me, "Nguyen Thanh Tuan").name) // Nguyen Thanh Tuan
    console.log(me.name) // Nguyen Thanh Tuan
</code></pre>
    <p>Như vậy chúng ta thấy ở đây, đối số person đã bị thay đổi giá trị, do đó
      đây không phải là pure function. Để làm cho đối số không bị thay đổi,
      chúng ta sẽ tạo ra một bản sao của person và thay đổi trên bản sao này</p>
    <pre><code>    let me = {
      name: "Thanh Tuan",
      favorite: "Programming"
    }

    // a pure function
    const changeName = (person, newName) =&gt; ({
      ...person,
      name: newName
    })
    console.log(changeName(me, "Nguyen Thanh Tuan").name) // Nguyen Thanh Tuan
    console.log(me.name) // Thanh Tuan
</code></pre>
    <p>Như vậy, <code>changeName</code> đã trở thành một pure function. Ở đây
      mình cũng chú ý một cách viết gọn và nhanh hơn như sau:</p>
    <pre><code>    // a pure function
    const changeName = (person, name) =&gt; ({
      ...person,
      name
    })
</code></pre>
    <p>Ở đây, bộ dịch sẽ tự hiểu được lấy tên đối số là key và giá trị của đối
      số là value trong object. Các bạn chú ý nhé.</p>
    <h3>Data Transformations</h3>
    <p>Để giảm thiểu sự phức tạp và đảm bảo tính immutability, Javascript đã
      cung cấp một số function để hỗ trợ mạnh mẽ cho chúng ta.</p>
    <h4>join</h4>
    <p>Khi chúng ta muốn nối các phần tử của một mảng thành một chuỗi, đơn giản
      chúng ta sẽ sử dụng <code>join</code> function. Ví dụ:</p>
    <pre><code>    let schools = [
      "Thanh Tri",
      "Linh Nam",
      "Tran Phu"
    ]

    // join function: array to string
    console.log(schools.join(", ")) // Thanh Tri, Linh Nam, Tran Phu
</code></pre>
    <h4>filter</h4>
    <p>Nếu chúng ta muốn tạo một mảng gồm các <code>school</code> có tên bắt
      đầu bằng chữ <code>T</code>. Chúng ta sử dụng <code>filter</code>
      function.</p>
    <pre><code>    // filter function: array to new array
    const tSchools = schools.filter(school =&gt; school[0] === "T")
    console.log(tSchools)
</code></pre>
    <p><code>Array.filter</code> function là một function chuyển đổi từ một mảng
      nguồn thành một mảng mới với đối số là một function (function này luôn
      luôn trả về <code>true</code> hoặc <code>false</code>) - <code>predicate</code>
      function. <code>Array.filter</code> sẽ gọi <code>predicate</code> mỗi
      lần tương ứng với mỗi phần tử của mảng nguồn. Nếu phần tử thỏa mãn điều
      kiện trong <code>predicate</code> thì sẽ được thêm vào mảng mới.</p>
    <p><code>Array.filter</code> là một immutable function, do đó khi muốn xóa
      một phần tử từ một mảng chúng ta nên sử dụng function này thay thế cho
      Array.pop hoặc Array.splice. Ví dụ:</p>
    <pre><code>    const cutSchools = (cut, list) =&gt; list.filter(item =&gt; item !== cut)
    console.log(cutSchools("Thanh Tri", schools)) // Array [ "Linh Nam", "Tran Phu" ]
</code></pre>
    <h4>map</h4>
    <p><code>Arrray.map</code> cũng chuyển đổi một array thành một new array.
      Tuy nhiên đối số của <code>map</code> khác với đối số của <code>filter</code>.
      Đối số của <code>map</code> là một function và kết quả trả về từ function
      này sẽ được thêm vào mảng mới. Ví dụ:</p>
    <pre><code>    // map function: array to new array
    const highSchools = schools.map(school =&gt; `${school} high school`)
    console.log(highSchools) // Array(3) [ "Thanh Tri high school", "Linh Nam high school", "Tran Phu high school" ]
</code></pre>
    <p>Ngoài ra, <code>map</code> cũng có thể chuyển một object thành một mảng
      các object. Ví dụ:</p>
    <pre><code>    // map function: object to array
    schools = {
      "Thanh Tri": 10,
      "Tran Phu": 2
    }
    const schoolsArray = Object.keys(schools).map(key =&gt; ({
      name: key,
      wins: schools[key]
    }))
    console.log(schoolsArray) // Array [{name: "Thanh Tri", wins: 10}, {name: "Tran Phu", wins: 2}]
</code></pre>
    <p><code>Object.keys</code> là một function trả về một mảng gồm tất cả các <code>key</code>
      của một object. Các bạn chú ý nhé.</p>
    <h4>reduce và reduceRight</h4>
    <p><code>Array.reduce</code> và <code>Array.reduceRight</code> là hai
      function sẽ chuyển đổi từ một mảng thành một giá trị bất kỳ như kiểu số,
      kiểu chuỗi, kiểu boolean hoặc thậm chí là một function. Ví dụ chúng ta
      muốn tìm giá trị lớn nhất (max) của một mảng số, chúng ta sẽ sử dụng <code>reduce</code>.</p>
    <pre><code>    // reduce and reduceRight function: array to value (number, string, object, boolean, ...)
    // array to number
    const ages = [23, 45, 98, 57]
    const maxAge = ages.reduce((max, current) =&gt; max &gt;= current ? max: current, 0)
    console.log(maxAge) // 98
</code></pre>
    <p>Đối số của function là callback function và giá trị khởi tạo. Ở ví dụ
      trên giá trị khởi tạo là 0. <code>Callback</code> function sẽ được gọi
      tương ứng một lần với mỗi phần tử của mảng. Đối số của <code>callback</code>
      sẽ là giá trị trả về từ lần gọi trước đó và phần tử của mảng hiện tại.</p>
    <ul>
      <li>Lần 1: max = 0, current = 23 =&gt; return 23 (ban đầu max chính bằng
        giá trị khởi tạo ban đầu)</li>
      <li>Lần 2: max = 23, current = 45 =&gt; return 45</li>
      <li>Lần 3: max = 45, current = 98 =&gt; return 98</li>
      <li>Lần 4: max = 98, current = 57 =&gt; return 98 - final =&gt; MAX = 98
        Tương tự khi sử dụng <code>reduceRight</code> cũng sẽ hoạt động như
        trên nhưng có một điểm khác là function này sẽ duyệt mảng từ phải qua
        trái.</li>
    </ul>
    <p>Một ví dụ khác chúng ta sẽ sử dụng <code>reduce</code> để chuyển đổi một
      mảng thành một mảng mới. Ví dụ:</p>
    <pre><code>    const colors = ["red", "red", "green", "blue", "green"]
    const distinctColors = colors.reduceRight((distinct, color) =&gt; 
      distinct.indexOf(color) === -1 ? [...distinct, color] : distinct
    , [])
    console.log(distinctColors) // Array(3) [ "red", "green", "blue" ]
</code></pre>
    <p><code>Array.indexOf</code> là function trả về vị trí của phần tử đó trong
      mảng, nếu mảng không chứa phần tử đó thì sẽ return về <code>-1</code>.
      Các bạn có thể thử viết cách hoạt động của ví dụ trên để hiểu rõ hơn nhé.</p>
    <p>Trên là 4 function được sử dụng nhiều nhất để chuyển đổi dữ liệu mảng
      trong JavaScript. Hy vọng phần này giúp bạn hiểu rõ hơn về tư tưởng của
      lập trình hàm trong JavaScript.</p>
    <h3>Higher-Order Functions</h3>
    <p>Higher-Order Functions là các function có thể sử dụng các function khác.
      Chúng ta có đưa function như một đối số (arguments) hoặc trả về (return)
      function hoặc cũng có thể cả hai.</p>
    <p>Như ở phần trước, <code>Array.map, Array.filter, Array.reduce</code> đều
      sử dụng function như một đối số do đó các function này đều là higher-order
      functions.</p>
    <p>Chúng ta sẽ xét một ví dụ sau:</p>
    <pre><code>    const show = (condition, funcTrue, funcFalse) =&gt; condition ? funcTrue() : funcFalse()
    const showWelcome = () =&gt; console.log("Welcome")
    const showUnauthorized = () =&gt; console.log("Unauthorized")

    show(true, showWelcome, showUnauthorized) // Welcome
    show(false, showWelcome, showUnauthorized) // Unauthorized
</code></pre>
    <p>Higher-Order function sẽ giúp chúng ta handle được các trường hợp phức
      tạp với các task bất đồng bộ trong JavaScript.</p>
    <h3>Recursion</h3>
    <p>Recursion - đệ quy là một kỹ thuật để một function có thể gọi lại chính
      nó. Ví dụ:</p>
    <pre><code>    // recursion
    const countdown = (value, func) =&gt; {
      func(value)
      return value &gt; 0 ? setTimeout(() =&gt; countdown(value - 1, func), 1000) : value
    }
    countdown(10, mess =&gt; console.log(mess))
</code></pre>
    <p>Đệ quy cũng được áp dụng khá nhiều ở các ngôn ngữ lập trình khác, do đó
      function trên mình thấy khá dễ hiểu nên không giải thích nữa nhé.</p>
    <h3>Composition</h3>
    <p>Trong lập trình nhiều trường hợp chúng ta sẽ thấy kết quả của function
      này là đối số của function khác. Composition là một kỹ thuật dùng để sinh
      ra một higher-order function bằng việc tổ hợp các function đơn giản. Ví
      dụ:</p>
    <pre><code>    // composition
    const returnDate = date =&gt; date.getDate()
    const logger = value =&gt; console.log(value)
    // kết quả của function này là đối số của function khác
    const both = date =&gt; logger(returnDate(date))
    both(new Date)
</code></pre>
    <p>Ở ví dụ trên, <code>both</code> là một function tổ hợp của <code>logger</code>
      và <code>returnDate</code>. Tuy nhiên với cú pháp trên có một vấn đề xảy
      ra khi số lượng function ở đây là số lượng lớn, khi đó chúng ta rất khó để
      bảo trì và mở rộng. Chúng ta sẽ xem xét một hướng đi khác cho kỹ thuật <code>compositon</code>
      như sau:</p>
    <pre><code>    const compose = (...funs) =&gt; (arg) =&gt; funs.reduce((composed, f) =&gt; f(composed), arg)

    const both2 = compose(
      returnDate,
      logger
    )
    both2(new Date)
</code></pre>
    <p>Để dễ hiểu hơn, mình sẽ viết hoạt động của <code>compose</code> function
      như sau:</p>
    <pre><code>1. composed = arg; f = returnDate
2. composed = returnDate(arg), f = logger
3. both2 = arg =&gt; logger(returnDate(arg))
</code></pre>
    <p>Nói cách khác, sau khi <code>compose</code> các function chúng ta sẽ lại
      thu được một function tương tự như <code>both</code> function. Tuy nhiên
      với cú pháp ở trên, chúng ta sẽ dễ dàng hơn khi muốn thêm một function nào
      đó vào trong logic của <code>both2</code> function. Một lợi ích nữa là
      chúng ta có thể thay đổi thứ tự gọi của các function được linh hoạt hơn.</p>
    <h3>Summary</h3>
    <p>Trên đây là những kiến thức cơ bản khi lập trình hàm trong JavaScript. Có
      3 điểm chúng ta cần nhớ khi đi theo mô hình lập trình này (trong
      Javascript):</p>
    <ol>
      <li>Giữ dữ liệu không bị thay đổi.</li>
      <li>Sử dụng các pure function (có ít nhất một đối số và trả về dữ liệu
        hoặc một function khác và không làm thay đổi giá trị của đối số).</li>
      <li>Sử dụng đệ quy để thay thế vòng lặp khi có thể.</li>
    </ol>
    <p>Hy vọng bài viết này sẽ giúp được các bạn phần nào hiểu được tư tưởng và
      cách áp dụng mô hình lập trình hàm nói chung và trong JavaScript nói
      riêng.</p>
    <p>Tài liệu tham khảo: <a href="http://shop.oreilly.com/product/0636920049579.do"
        target="_blank">http://shop.oreilly.com/product/0636920049579.do</a></p>
    <p>Cảm ơn các bạn đã đọc bài viết. Happy coding!!!</p>
    <p></p>
  </body>
</html>
