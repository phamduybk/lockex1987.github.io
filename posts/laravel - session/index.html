<!doctype html>
<html>
 <head> 
  <meta content="text/html; charset=UTF-8" http-equiv="content-type"> 
  <title>Laravel Session</title> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <link rel="icon" href="../../images/favicon.png"> 
  <link rel="stylesheet" href="../../css/style.css"> 
  <meta name="description" content="Laravel Session">
 </head> 
 <body> 
  <article> 
   <h1>HTTP Session</h1> 
   <p>Khi hệ thống HTTP không có chỗ lưu trữ, session cung cấp một cách để lưu thông tin từ các yêu cầu của người dùng. Laravel cung cấp đầy đủ session backends thông qua API để hỗ trợ việc này. Hỗ trợ các backend như Memcached, Redis, và cơ sở dữ liệu đã có sẵn.</p> 
   <h3>Cấu hình</h3> 
   <p>File cấu hình session lưu ở <code>config/session.php</code>. Hãy chắc rằng bạn nắm rõ tất cả các thông tin cấu hình của session trước khi tùy chỉnh lại tệp tin này. Mặc định, Laravel sẽ cấu hình sử dụng <code>file </code>session driver, nó sẽ hoạt động tốt cho nhiều ứng dụng. Đối với production, bạn có thể cân nhắc sử dụng <code>memcached</code> hoặc <code>redis</code> drivers để cho hiệu năng của session tốt hơn.</p> 
   <p>Các session <code>driver</code> được định nghĩa là nơi lưu trữ dữ liệu session qua các request. Laravel đã tích hợp sẵn một số session driver sau:</p> 
   <div> 
    <ul> 
     <li><code>file</code> - sessions sẽ lưu tại <code>storage/framework/sessions</code>.</li> 
     <li><code>cookie</code> - sessions sẽ lưu có bảo mật, mã hóa cookies.</li> 
     <li><code>database</code> - sessions sẽ lưu trong cơ sở dữ liệu được dùng trong ứng dụng của bạn.</li> 
     <li><code>memcached</code> / <code>redis</code> - sessions sẽ lưu và truy suất nhanh hơn, dựa trên cache.</li> 
     <li><code>array</code> - sessions sẽ được lưu trong mảng PHP và sẽ tồn tại lâu.</li> 
    </ul> 
   </div> 
   <p> Với array driver chỉ nên sử dụng khi chạy <a href="https://giaphiep.com/docs/5.3/testing">testing</a> để có các dữ liệu tồn tại trong thời gian dài.</p> 
   <h3>Driver Prerequisites</h3> 
   <h4>Cơ sở dữ liệu</h4> 
   <p>Khi sử dụng <code>database</code> session driver, bạn cần phải tạo bảng chứa dữ liệu session trong cơ sở dữ liệu. Bên dưới là một ví dụ <code>Schema</code> dùng tạo bảng:</p> 
   <pre><code>Schema::create('sessions', function ($table) {
    $table-&gt;string('id')-&gt;unique();
    $table-&gt;integer('user_id')-&gt;nullable();
    $table-&gt;string('ip_address', 45)-&gt;nullable();
    $table-&gt;text('user_agent')-&gt;nullable();
    $table-&gt;text('payload');
    $table-&gt;integer('last_activity');
});</code></pre> 
   <p>Bạn có thể sử dụng <code>session:table</code> trong Artisan command để tự động tạo migration:</p> 
   <pre><code>php artisan session:table

php artisan migrate</code></pre> 
   <h4>Redis</h4> 
   <p>Trước khi sử dụng Redis sessions với Laravel, bạn cần cài đặt gói <code>predis/predis</code> package (~1.0) qua Composer. Bạn cấu hình Redis của bạn kết nối trong file cấu hình <code>database</code>. Trong file cấu hình <code>session</code>, thuộc tính <code>connection</code> có thể được sử dụng để xác định kết nối với Redis là sử dụng session.</p> 
   <h2>Sử dụng Session</h2> 
   <h3>Nhận dữ liệu</h3> 
   <p>Có hai cách chính để làm việc với dữ liệu session data trong Laravel: phương thức global <code>session</code> và qua thể hiện <code>Request</code>. Đầu tiên, Chúng ta nhìn cách truy cập session qua thể hiện <code>Request</code>, có thể được type-hinted trong phương thức controller. Nhớ rằng, phương thức controller dependencies tự động injected qua Laravel <a href="https://giaphiep.com/docs/5.3/container">service container</a>:</p> 
   <pre><code>&lt;?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Http\Controllers\Controller;

class UserController extends Controller
{
    /**
     * Show the profile for the given user.
     *
     * @param    Request  $request
     * @param    int  $id
     * @return  Response
     */
    public function show(Request $request, $id)
    {
        $value = $request-&gt;session()-&gt;get('key');

        //
    }
}</code></pre> 
   <p>Khi bạn nhận giá trị từ session, bạn cũng có thể truyền giá trị mặc định qua tham số thứ hai của phương thức <code>get</code>. Giá trị mặc định sẽ được trả về nếu key không tồn tại trong session. Nếu bạn truyền vào một <code>Closure</code> là giá trị mặc định của phương thức <code>get</code> và requested key không tồn tại, thì <code>Closure</code> sẽ được thực thi và trả về giá trị return:</p> 
   <pre><code>$value = $request-&gt;session()-&gt;get('key', 'default');

$value = $request-&gt;session()-&gt;get('key', function() {
    return 'default';
});</code></pre> 
   <h4>Phương thức Global Session</h4> 
   <p>Bạn cũng có thể sử dụng hàm global <code>session</code> của PHP và lưu dữ liệu trong session. Khi hàm <code>session</code>được gọi, chuỗi tham số, nó sẽ trà về giá trị của key session. Khi hàm được gọi với một cặp giá trị key / value, giá trị sẽ lưu trong session:</p> 
   <pre><code>Route::get('home', function () {
    // Retrieve a piece of data from the session...
    $value = session('key');

    // Specifying a default value...
    $value = session('key', 'default');

    // Store a piece of data in the session...
    session(['key' =&gt; 'value']);
});</code></pre> 
   <p> Có rất ít sự khác biệt giữa sử dụng session qua HTTP request và sử dụng hàm global <code>session</code>. Cả hai phương thức là <a href="https://giaphiep.com/docs/5.3/testing">testable</a> qua phương thức <code>assertSessionHas</code> nó tồn tại trong tất cả các test cases của bạn.</p> 
   <h4>Nhận tất cả dữ liệu Session</h4> 
   <p>Nếu bạn muốn nhận tất cả dữ liệu của session, bạn có thể sử dụng phương thức <code>all</code>:</p> 
   <pre><code>$data = $request-&gt;session()-&gt;all();</code></pre> 
   <h4>Kiểm tra sự tồn tại của Session</h4> 
   <p>Để xác sự tồn tại session, bạn có thể sử dụng phương thức <code>has</code>. Phương thức sẽ trả về <code>has</code> <code>true</code>, nếu giá trị của session không bằng <code>null</code>:</p> 
   <pre><code>if ($request-&gt;session()-&gt;has('users')) {
    //
}</code></pre> 
   <p>Để xác sự tồn tại session, ngay cả giá trị của nó bằng <code>null</code>, bạn có thể sử dụng phương thức <code>exists</code>. Phương thức <code>exists</code> trả về <code>true</code> nếu giá trị tồn tại:</p> 
   <pre><code>if ($request-&gt;session()-&gt;exists('users')) {
    //
}</code></pre> 
   <h3>Lưu dữ liệu</h3> 
   <p>Để lưu dữ liệu trong session, bạn sẽ thường sử dụng phương thức <code>put</code> hoặc hàm<code> session</code>:</p> 
   <pre><code>// Via a request instance...
$request-&gt;session()-&gt;put('key', 'value');

// Via the global helper...
session(['key' =&gt; 'value']);</code></pre> 
   <h4>Đẩy giá trị vào mảng Session</h4> 
   <p>Phương thức <code>push</code> có thể sử dụng để đẩy một giá trị vào một biến mảng session. Ví dụ, nếu trong <code>user.teams</code> là một mảng chứa tên nhóm, bạn có thể đẩy tên nhóm mới vào mảng theo cách sau:</p> 
   <pre><code>$request-&gt;session()-&gt;push('user.teams', 'developers');</code></pre> 
   <h4>Nhận &amp; xóa một item</h4> 
   <p>Phương thức <code>pull</code> sẽ nhận và xóa một item từ session trong một lệnh:</p> 
   <pre><code>$value = $request-&gt;session()-&gt;pull('key', 'default');</code></pre> 
   <h3>Flash Data</h3> 
   <p>Thỉnh thoảng bạn có một vài dữ liệu mà chỉ muốn nó lưu tại lần truy xuất tiếp theo. Bạn có thể dùng phương thức <code>flash</code>. Dữ liệu lưu trong session sử dụng phương thức trên chỉ tồn tại duy nhất trong lần HTTP request tiếp theo, sau đó sẽ tự động được xóa. Flash data thường dùng để biểu thị các trạng thái, thông báo, tin nhắn:</p> 
   <pre><code>$request-&gt;session()-&gt;flash('status', 'Task was successful!');</code></pre> 
   <p>Nếu bạn muốn giữa dữ liệu trong nhiều lần request, bạn có thể sử dụng phương thức <code>reflash</code>, nó sẽ dữ lại tất cả các dữ liệu flash thêm vào request. Nếu bạn muốn dữ nội dung flash cụ thể, bạn có thể dung phương thức <code>keep</code>:</p> 
   <pre><code>$request-&gt;session()-&gt;reflash();

$request-&gt;session()-&gt;keep(['username', 'email']);</code></pre> 
   <p><a></a></p> 
   <h3>Xóa Data</h3> 
   <p>Phương thức <code>forget</code> sẽ xóa tưng phần dữ liệu từ session. Nếu bạn muốn xóa tất cả dữ liệu session, bạn có thể sử dụng phương thức<code>flush</code>:</p> 
   <pre><code>$request-&gt;session()-&gt;forget('key');

$request-&gt;session()-&gt;flush();</code></pre> 
   <p><a></a></p> 
   <h3>Regenerating The Session ID</h3> 
   <p>Regenerating the session ID thường gặp khi ngăn một mã độc từ người dùng khai thác một <a href="https://en.wikipedia.org/wiki/Session_fixation">session fixation</a> tấn công ứng dụng của bạn.</p> 
   <p>Laravel tự động regenerates the session ID khi xác thực nếu bạn sử dụng built-in <code>LoginController</code>; tuy nhiên, nếu bạn cần tự tay regenerate the session ID, bạn có thể sử dụng phương thức <code>regenerate</code>.</p> 
   <pre><code>$request-&gt;session()-&gt;regenerate();</code></pre> 
   <h2>Adding Custom Session Drivers</h2> 
   <h4>Implementing The Driver</h4> 
   <p>Tùy biến session driver của bạn nên thực hiện trong <code>SessionHandlerInterface</code>. Nó chứa một vài phương thức chúng ta cần để thực thi. Một stubbed MongoDB thực hiện giống như bên dưới:</p> 
   <pre><code>&lt;?php

namespace App\Extensions;

class MongoHandler implements SessionHandlerInterface
{
    public function open($savePath, $sessionName) {}
    public function close() {}
    public function read($sessionId) {}
    public function write($sessionId, $data) {}
    public function destroy($sessionId) {}
    public function gc($lifetime) {}
}</code></pre> 
   <p> Laravel không cung cấp đường dẫn chứa extensions của bạn. bạn có thể thoải mái đặt ở đâu bạn thích. Trong ví dụ trên, chúng ta sẽ tạo một đường dẫn <code>Extensions</code> chứa <code>MongoHandler</code>.</p> 
   <p>Mục đích của những phương thức này không thật sự khó hiểu, chúng ta sẽ tìm hiểu sơ về những phương thức đó:</p> 
   <div> 
    <ul> 
     <li>Phương thức <code>open</code> thường được sử dụng trong các fiel. Từ khi Laravel cung cấp một <code>file </code>session driver, Bạn sẽ hầu như không cần dùng phương thức này. Bạn có thể để nó như 1 emptry stub. Nó chỉ đơn giản là thực tế của giao diện kém (chúng ta sẽ tìm hiểu nó sau) mà PHP yêu cầu thực hiện phương thức này.</li> 
     <li>Phương thức <code>close</code> , giống như phương thức <code>open</code> , cũng có thể thường bỏ qua. hầu hết các drivers, nó không cần thiết.</li> 
     <li>Phương thức <code>read</code> sẽ trả về chuỗi các dữ liệu session liên quan đến kiểm soát của<code> $sessionId</code>. Ở đây không phải làm bất kỳ serialization hoặc encoding khi nhận hoặc lưu dữ liệu session trong driver, Laravel sẽ làm serialization cho bạn.</li> 
     <li>Phương thức <code>write</code> sẽ viết các giá trị chuỗi <code>$data</code> liên quan tới <code>$sessionId</code> đến một vài hệ thống persistent storage như MongoDB, Dynamo, etc. Một lần nữa, bạn không cần phải serialization - Laravel đã xử lý việc đó cho bạn.</li> 
     <li>Phương thức <code>destroy</code> sẽ xóa dữ liệu session liên quan tới <code>$sessionId</code> từ persistent storage.</li> 
     <li>Phương thức <code>gc</code>sẽ xóa tất cả dữ liệu session cũ hơn giá trị mới <code>$lifetime</code>, bằng doạn UNIX timestamp. Đối với hệ thống tự hết hạn như Memcached và Redis, phương thức này có thể được bỏ trống.</li> 
    </ul> 
   </div> 
   <h4>Đăng ký The Driver</h4> 
   <p>Khi drivẻ của bạn được thực hiện, bạn đã sẵn sàng đăng ký nó với framework. Bổ sung thêm drivers vào session backend của Laravel, bạn có thể sử dụng phương thức <code>extend</code> trong <code>Session</code> <a href="https://giaphiep.com/docs/5.3/facades">facade</a>. Bạn nên gọi phương thức <code>extend</code> từphương thức <code>boot</code> của <a href="https://giaphiep.com/docs/5.3/providers">service provider</a>. Bạn có thể làm điều này từ <code>AppServiceProvider</code> hoặc tạo mới một provider:</p> 
   <pre><code>&lt;?php

namespace App\Providers;

use App\Extensions\MongoSessionStore;
use Illuminate\Support\Facades\Session;
use Illuminate\Support\ServiceProvider;

class SessionServiceProvider extends ServiceProvider
{
    /**
     * Perform post-registration booting of services.
     *
     * @return  void
     */
    public function boot()
    {
        Session::extend('mongo', function($app) {
            // Return implementation of SessionHandlerInterface...
            return new MongoSessionStore;
        });
    }

    /**
     * Register bindings in the container.
     *
     * @return  void
     */
    public function register()
    {
        //
    }
}</code></pre> 
   <p>Khi session driver đã được đăng ký, bạn có thể sử dụng <code>mongo</code> driver trong file cấu hình <code>config/session.php</code>.</p> 
   <p> Nguồn: <a href="https://laravel.com/docs/5.3/session">https://laravel.com/docs/5.3/session</a> </p> 
  </article> 
  <script src="../../js/docs.js"></script>  
 </body>
</html>