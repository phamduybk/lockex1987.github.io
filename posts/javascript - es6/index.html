<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>JavaScript - ES6</title>
  </head>
  <body>
    <h1>ES6 Const và Let</h1>
    <p>Trong ES5 chúng ta chỉ có một cách duy nhất để để khai báo biến đó là <code>var</code>,
      trong ES6 chúng ta có hai cách khách nhau đó là sử dụng <code>const</code>
      và <code>let</code> để khai báo biến.</p>
    <h2><code>const</code> và <code>let</code> Là Gì</h2>
    <p>Trong phiên bản ES5 và trước đó để khai báo một biến chúng ta sử dụng từ
      khoá <code>var</code>:</p>
    <pre><code>var student_name = "Super Man";
var student_age = 200;</code></pre>
    <p>Trong ES6 chúng ta thường sẽ không sử dụng <code>var</code> mà thay vào
      đó sẽ sử dụng <code>const</code> và <code>let</code>. Sự khác biệt ở đây
      đó là <code>const</code> dùng để khai báo các biến mà giá trị không thay
      đổi (hay hằng số) còn <code>let</code> sử dụng khai báo biến mà giá trị
      có thể thay đổi (tương tự như <code>var</code> trước đây):</p>
    <p>Với ví dụ phía trên nếu sử dụng ES6 chúng ta có thể sẽ viết lại như sau:</p>
    <pre><code>const student_name = "Super Man";
let student_age = 200;</code></pre>
    <h2>Tại Sao Nên Dùng <code>const</code> và <code>let</code></h2>
    <p>Trong các ứng dụng JavaScript phức tạp thì việc tách riêng hằng và biết
      sẽ giúp lập trình viên có thể dễ dàng kiểm soát được mã lệnh chương trình
      cũng như những thay đổi diễn ra trong đó. Ví dụ với các hằng số được khai
      báo với từ khoá <code>const</code> thì việc thay đổi giá trị của chúng sẽ
      sinh ra lỗi:</p>
    <pre>const student_name = "Super Man";
let student_age = 200;

// thay đổi sau sẽ dẫn tới phát sinh lỗi khi chạy chương trình
student_name ="Spider Man";</pre>
    <p>Hoặc ví dụ như bạn có một danh sách các môn thi đầu vào cho một ngành học
      của trường và bạn không muốn danh sách này bị thay đổi sau đó:</p>
    <pre><code>const subjects = ["Toán", "Văn", "Anh"];</code></pre>
    <p>Sử dụng <code>let</code> và <code>const</code> sẽ đặc biệt hữu dụng cho
      những dự án mà có nhiều lập trình viên tham gia hay cũng như việc một biến
      (hay hằng) được sử dụng ở nhiều tập tin khác nhau.</p>
    <p>-----------------------------------------------------------------------</p>
    <h1>ES6 Rest Parameter</h1>
    <p>Rest parameter trong ES6 giúp chúng ta có thể định nghĩa một hàm với số
      lượng tham số có thể thay đổi tuỳ ý. Hay nói theo cách khác khi chúng ta
      không biết chắc chắn số lượng tham số cần có của một hàm chúng ta có thể
      sử dụng rest parameter.</p>
    <pre><code>function f(param_1, param_2, ...rest_parameter) {
  // ...
}</code></pre>
    <h2>Cú Pháp Rest Parameter</h2>
    <p>Rest parameter được phân biệt với các parameter thông thường thông qua 3
      dấu chấm <code>...</code> được đặt phía trước tên của parameter đặc biệt
      này:</p>
    <pre><code>function f(param_1, param_2, ...rest_parameter) {
  // ...
}</code></pre>
    <p>Ví dụ:</p>
    <pre><code>// Tham số "numbers" ở ví dụ dưới là một rest parameter
function sumNumbers(...numbers) {  
  console.log(numbers);
}

// Gọi hàm "sumNumbers()"
sumNumbers(2, 3); // [2, 3]
sumNumbers(2, 3, 100); // [2, 3, 100]</code></pre>
    <h2>Sử Dụng Rest Parameter</h2>
    <p>Rest parameter nhóm tất cả các đối số truyền vào khi gọi hàm thành một
      array (bỏ qua các đối số truyền vào cho tham số thông thường của hàm).</p>
    <pre><code>function sumNumbers(message, ...numbers) {
  let total = 0;
  for (var i = 0; i &lt; numbers.length; i++) {
    total += numbers[i];
  }
  console.log(message, total);
}

sumNumbers("Tổng là: ", 2, 3); // Tổng là:  5
sumNumbers("Giá trị của tổng là: ", 2, 3, 100); // Giá trị của tổng là:  105</code></pre>
    <p>------------------------------------</p>
    <h1>ES6 Spread Operator</h1>
    <p>Spread operator có cú pháp giống với rest paraterter tuy nhiên cả hai có
      ý nghĩa khác nhau. Rest paramter được sử dụng khi khai báo hàm, ngược lại
      spread operator được sử dụng trong các câu lệnh, biểu thức hoặc khi gọi
      hàm.</p>
    <p>Để hiểu về spread operator chúng ta sẽ cùng tham khảo một số ví dụ tiếp
      sau đây.</p>
    <h2>Sử Dụng Spread Operator Với Mảng</h2>
    <h3>Nối Mảng (Concatenate Array)</h3>
    <p>Trước khi ES6 được ra đời thì cách phổ biến để nối mảng là sử dụng phương
      thức <code>concat()</code> của một mảng với đối số truyền vào là những
      mảng khác sẽ được nối với mảng này:</p>
    <pre><code>var arr_1 = [1, 2, 3];
var arr_2 = [4, 5, 6];

arr_3 = arr_1.concat(arr_2);
console.log(arr_3); //  [1, 2, 3, 4, 5, 6]</code></pre>
    <p>Sử dụng spread operator trong ES6 đoạn code trên có thể được viết lại như
      sau:</p>
    <pre><code>arr_3 = [...arr_1, ...arr_2];</code></pre>
    <h3>Gộp Với Giá Trị Khác</h3>
    <p>Với spread operator chúng ta còn có thể kết hợp một mảng với giá trị
      khác:</p>
    <pre><code>var numbers = [1, 2, 3]; 
result = ["Car", numbers, "Motobike"];</code></pre>
    <p>Với phiên bản trước của ECMAScript để thực hiện việc gộp mảng với các giá
      trị tuỳ ý khác như trên sẽ cần sử dụng tới rất nhiều các phương thức khác
      nhau như <code>concat()</code>, <code>push()</code>, <code>slide()</code>.</p>
    <h2>Sử Dụng Spread Operator Với Object</h2>
    <h3>Copy Object</h3>
    <p>Sử dụng spread operator chúng ta có thể dễ dàng copy object như sau:</p>
    <pre><code>var obj_1 = { name: 'ECMAScript' };

var cloned_obj = { ...obj_1 };
console.log(cloned_obj);
// { name: 'ECMAScript' }</code></pre>
    <h3>Gộp Object</h3>
    <p>Chúng ta cũng có thể sử dụng spread operator để gộp các object với nhau:</p>
    <pre><code>var obj_1 = { name: 'ECMAScript' };
var obj_2 = { year: 2015 };

var cloned_obj = { ...obj_1, ...obj_2 };
console.log(cloned_obj); // { name: 'ECMAScript' }
// {name: "ECMAScript", year: 2015}</code></pre>
    <h2>Sử Dụng Spread Operator Với Hàm</h2>
    <p>Với các hàm được khai báo với nhiều tham số khác nhau thì sử dụng spread
      operator cho phép chúng ta truyền vào một giá trị duy nhất là một mảng:</p>
    <pre><code>function myFn (param_1, param_2, param_3) {
}
var args = [1, 2, 3];
myFn(...args);</code></pre>
    <p>Chúng ta cũng có thể sử dụng spread operator kết hợp với đối số thông
      thường:</p>
    <pre><code>function myFn (param_1, param_2, param_3, param_4, param_5) {
}
var args = [2, 3, 4];
myFn(1, ...args, 5);</code></pre>
    <p>------------------------------</p>
    <h1>ES6 Default Parameter</h1>
    <h2>Tham Số Mặc Định</h2>
    <p>Trong nhiều trường hợp, khi định nghĩa một hàm chúng ta muốn gán giá trị
      mặc định cho tham số trong hàm để khi hàm được gọi nếu không có giá trị
      nào truyền vào cho các tham số này thì giá trị mặc định của chúng sẽ được
      sử dụng.</p>
    <p>Với các phiên bản trước của ECMAScript không cung cấp sẵn tính năng gán
      giá trị mặc định cho tham số của hàm mà thông thường cần phải thực hiện
      thông qua một số bước gián tiếp khác để đạt được mục đính tương tự. Trong
      ECMAScript 6, tính năng gán giá trị mặc định cho tham số đã được hỗ trợ:</p>
    <pre><code>function sayHi(name = 'there') {
    console.log("Hi " + name + '!');
}</code></pre>
    <p>Tham số <code>name</code> trong <code>sayHi()</code> ở đoạn code trên
      sẽ được gán giá trị đối số mặc định với giá trị là <code>there</code>.
      Khi gọi hàm <code>sayHi()</code> được định nghĩa như ở ví dụ trên, nếu
      như chúng ta không truyền vào giá trị (hay đối số) nào cho tham số <code>name</code>
      trong hàm này thì giá trị mặc định <code>there</code> sẽ được sử dụng:</p>
    <pre><code>sayHi('John');
// Hi John!

sayHi();
// Hi there!</code></pre>
    <p>Lưu ý: Một số ngôn ngữ lập trình khác sử dụng thuật ngữ đối số mặc định
      (default argument) thay vì tham số mặc định (default parameter). Mặc dù
      hai thuật ngữ parameter và argument (không có default phía trước) có ý
      nghĩa khác nhau, default argument và default parameter trong ngữ cảnh này
      có ý nghĩa như nhau.</p>
    <h2>Đối Số <code>undefined</code></h2>
    <p>Trong khi gọi hàm, với các tham số được khai báo với giá trị đối số mặc
      định thì việc sử dụng đối số với giá trị là <code>undefined</code> tương
      đương với việc không truyền vào đối số (hay sử dụng đối số mặc định).</p>
    <pre><code>function sayHi(name = 'there') {
    console.log("Hi " + name + '!');
    console.log(typeof name);
}

sayHi();
// Hi there!
// string

sayHi(undefined);
// Hi there!
// string</code></pre>
    <p>Ngoài <code>undefined</code> ra thì tất cả các giá trị khác sử dụng cho
      tham số vẫn được sử dụng thông thường thay vì sử dụng đối số mặc định:</p>
    <pre><code>sayHi(null);

// Hi null!
// object

sayHi(false);
// Hi false!
// boolean</code></pre>
    <p>--------------------------</p>
    <h1>ES6 Object Literal</h1>
    <h2>Object Literal Là Gì</h2>
    <p>Object trong JavaScript có thể được tạo theo một số cách khác nhau.
      Object literal là kiểu cú pháp tạo object sử dụng cặp dấu ngoặc <code>{}</code>
      và bên trong đó là danh sách các property (thuộc tính) của object.</p>
    <p>Với phiên bản ECMAScript trước đây chúng ta thường sẽ</p>
    <pre><code>var name = "John";
var myObj = { name: name };</code></pre>
    <p>Các property có giá trị là một hàm còn được gọi là method:</p>
    <pre><code>var name = "John";
var myObj = {
    name: name,
    sayHi: function () {
        console.log("Hi, my nam is " + this.name)
    }
};</code></pre>
    <h2>Cú Pháp Object Literal Trong ES6</h2>
    <p>Trong ECMAScript 6 cú pháp khởi tạo object sử dụng object literal được
      đơn giản hoá hơn.</p>
    <p>Với những property có tên trùng với giá trị như <code>name:name</code> ở
      trong ví dụ trên thì lập trình viên có thể thay thế bởi <code>name</code>:</p>
    <pre><code>let name = "John";
let myObj = { name };</code></pre>
    <p>Với các property nhận giá trị là một hàm (hay còn gọi là method) thì lập
      trình viên có thể thay thế bằng cách khai báo một với tên của property và
      đồng thời bỏ qua từ khoá <code>function</code>. Ví dụ với đoạn code sau
      khởi tạo object sử dụng kiểu cũ:</p>
    <pre><code>var name = "John";

var myObj = { 
    name: name,
    sayHi: function () {
        console.log("Hi, my nam is " + this.name)
    }
};

myObj.sayHi()
// Hi, my nam is John</code></pre>
    <p>Thì trong ES6 có thể được viết lại như sau:</p>
    <pre><code>let name = "John";

let myObj = { 
    name,
    sayHi() {
        console.log("Hi, my nam is " + this.name)
    }
};

myObj.sayHi()
// Hi, my nam is John</code></pre>
    <p>-------------------------</p>
    <h1>ES6 Template Literal</h1>
    <h2>Template Literal Là Gì</h2>
    <p>Template literal là tính năng mới trong ECMAScript 6 cho phép lập trình
      viên có thể nhúng biểu thứcJavaScript (ví dụ như giá trị của biến, hoặc
      kết quả của một phép toán...) bên trong chuỗi string một cách dễ dàng.</p>
    <p>Sử dụng phiên bản trước của ECMAScript thì việc nối chuỗi với giá trị của
      một biến hoặc biểu thức thường sử dụng toán tử <code>+</code> và chúng ta
      sẽ thường được thấy những đoạn code tương tự sau xuất hiện trong source
      code:</p>
    <pre><code>var spiderMan = {
    name: "Peter",
    age: 25
};

var superMan = {
    name: "Clark",
    age: 200
};

console.log("Hello, " + superMan.name
    + ", my name is " + spiderMan.name
    + ", I'm " + spiderMan.age + " years old."
    + " And you're " + superMan.age + " years old."
    + " Do you want to have a fight!!!");</code></pre>
    <p>Đoạn code trên khi chạy sẽ hiển thị kết quả sau trong tab console:</p>
    <pre><code>Hello, Clark, my name is Peter, I'm 25 years old. And you're 200 years old. Do you want to have a fight!!!</code></pre>
    <p>Sử Dụng template literal sẽ giúp chúng ta hạn chế sử dụng toán tử <code>+</code>
      như trên và source code nhìn sẽ gọn hơn.</p>
    <h2>Cú Pháp Template Literal</h2>
    <p>Template literal có cú pháp như sau:</p>
    <pre><code>`Text ${javascript_expression} other text...`</code></pre>
    <p>Trong đó <code>javascript_expression</code> là một biểu thức JavaScript.</p>
    <p>Ví dụ:</p>
    <pre><code>let firstName = "Peter";
let lastName = "Parker";

console.log(`Hello everyone! My name is ${firstName} ${lastName}.`);</code></pre>
    <p>Kết quả trả về:</p>
    <pre><code>Hello everyone! My name is Peter Parker.</code></pre>
    <p>Một ví dụ khác:</p>
    <pre><code>let toDay = new Date();

console.log(`Hôm nay là ngày ${toDay.getDate()} tháng ${toDay.getMonth()} năm ${toDay.getYear()}`);</code></pre>
    <p>Đoạn code trên khi chạy sẽ hiển thị kết quả sau trong tab console:</p>
    <pre><code>Hôm nay là ngày 13 tháng 10 năm 117</code></pre>
    <p>Lưu ý: Đối với các ký tự đặc biệt như xuống dòng, tab... thì chúng ta vẫn
      sử dụng cú pháp thoát ký tự đặc biệt trong JavaScript như thông thường. Ví
      dụ <code>\n</code> để xuống dòng, <code>\t</code> để thêm tab...</p>
    <p>-----------------------------------</p>
    <h1>ES6 Arrow Function</h1>
    <p>Arrow functon trong ECMAScript là kiểu cú pháp giúp đơn giản hoá việc
      việc định nghĩa hàm.</p>
    <h2>Cú Pháp Arrow Function</h2>
    <p>Trước khi sử dụng arrow function thì chúng ta hãy cùng xem cách định
      nghĩa một hàm JavaScript theo cách thông thường trước đây:</p>
    <pre><code>var sumNumbers = function (a, b) {
    return a + b;
}</code></pre>
    <p>Với tính năng arrow function trong ECMAScript 6 chúng ta có thể viết lại
      đoạn code trên như sau:</p>
    <pre><code>const sumNumbers = (a, b) =&gt; {
    return a + b;
}</code></pre>
    <p>Có 2 điểm bạn cần lưu ý ở cách viết trên:</p>
    <ul>
      <li>Từ khoá <code>function</code> được bỏ đi</li>
      <li>Thêm ký tự <code>=&gt;</code> (gần giống với mũi tên) đặt giữa dấu
        ngoặc kết thúc danh sách tham số <code>)</code> và dấu ngoặc bắt đầu
        logic của hàm <code>{</code></li>
    </ul>
    <p>Ngoài ra chúng ta thay từ khoá <code>var</code> bằng <code>const</code>
      để quy định rằng giá trị của <code>sumNumbers</code> sẽ không thay đổi
      (tất nhiên bạn có thể dùng <code>let</code> nếu muốn).</p>
    <h2>Giải Thích Cú Pháp</h2>
    <p>Rất nhiều lập trình viên cảm thấy cú pháp arrow function khó hiểu và thậm
      chí phức tạp hơn cú pháp định nghĩa hàm thông thường trong ECMAScript
      phiên bản trước. Để hiểu ý nghĩa của cú pháp arrow function thì chúng ta
      cần nhớ lại rằng về bản chất công dụng của một hàm đó là thực hiện các
      thao tác để biến đổi đầu vào (các tham số) để đưa ra một kết quả mới.</p>
    <p>Cùng xem lại ví dụ phía trên:</p>
    <pre><code>let sumNumbers = (a, b) =&gt; {
    return a + b;
}</code></pre>
    <ins data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7490225591585331"
      data-ad-slot="1172433020"></ins> <br>
    <p>Ký tự <code>=&gt;</code> (tương tự một dấu mũi tên) mang ý nghĩa rằng
      chúng ta sẽ biến đối các tham số đầu vào <code>a</code> và <code>b</code>
      ớ phía trước mũi tên và kết quả của sự chuyển đổi này được đặt ở phía sau
      mũi tên.</p>
    <h2>Hàm Với Một Tham Số Duy Nhất</h2>
    <p>Đối với các hàm được định nghĩa chỉ với một tham số thì bạn có thể bỏ qua
      cặp dấu ngoặc <code>()</code>:</p>
    <pre><code>let doubleNumber = a =&gt; {
    return a * 2;
}</code></pre>
    <p>Tuy nhiên nếu hàm không có đối số nào thì chúng ta vẫn phải sử dụng <code>()</code>:</p>
    <pre><code>let sayHello =&gt; () {
    console.log("Hello everyone!");
}</code></pre>
    <h2>Trả Về Giá Trị (Return Value)</h2>
    <p>Đối với các hàm mà bên trong đó chỉ chứa một câu lệnh duy nhất và câu
      lệnh này dùng để trả về giá trị cho hàm như ví dụ ở trên:</p>
    <pre><code>let sumNumbers = (a, b) =&gt; {
    return a + b;
}</code></pre>
    <p>Thì chúng ta có thể viết sử dụng cú pháp ngắn hơn sau:</p>
    <pre><code>let sumNumbers = (a, b) =&gt; a + b;</code></pre>
    <p>------------------------------</p>
    <h1>ES6 Destructuring Assignment</h1>
    <p>Destructuring assignment là một biểu thức JavaScript dùng để lấy ra
      (destructure) giá trị của một hay nhiều phần tử rong mảng hoặc đối tượng
      đồng thời gán các giá trị này cho các biến cho trước.</p>
    <p>Chúng ta cùng tham khảo một đoạn code ví dụ khá cơ bản dùng để
      destructure các thuộc tính trong đối tượng như sau:</p>
    <pre>var iPhone = {  
    model: "iPhone X",
    price: "$1500 USD",
    year: 2017
};

var model = iPhone.model;
var price = iPhone.price;
var year = iPhone.year;</pre>
    <p>Bạn có thể thấy sử dụng cú pháp như trên để destructure các thuộc tính
      trong đối tượng trôgn khá rườm rà. Câu hỏi đặt ra ở đây là có cách nào để
      nhanh tróng lấy ra các giá trị của đối tượng <code>iPhone</code>và gán
      cho các biến với tên cho trước hay không? Câu trả lời ở đây là có, thông
      qua sử dụng cú pháp destructuring assignment trong ES6:</p>
    <pre>let iPhone = {  
    model: "iPhone X",
    price: "$1500 USD",
    year: 2017
};

let { model, price, year } = iPhone;

console.log(model); // iPhone
console.log(price); // $1500 USD
console.log(year); // 2017</pre>
    <p>Cú pháp như trên trông gọn gàng hơn rất nhiều so với lúc trước!</p>
    <p>Destructuring assignment được sử dụng với kiểu dữ liệu đối tượng và mảng.
      Ở phần dưới đây chúng ta hãy cùng nhau đi sâu hơn vào chi tiết cách sử
      dụng của destructuring assignment trong ES6.</p>
    <h2>Destructuring Object</h2>
    <p>Destructuring object dùng để lấy ra các thuộc tính của object và gán giá
      trị của từng thuộc tính cho các biến với tên cho trước.</p>
    <p>Trường gán lấy ra giá trị của thộc tính object và gán cho biến với tên
      biến trùng tên với thuộc tính:</p>
    <pre><code>let iPhone = {  
    model: "iPhone X",
    price: "$1500 USD",
    year: 2017
};

let { model, price, year } = iPhone;</code></pre>
    <p>Trường hợp muốn sử dụng tên biến khác với tên thuộc tính của object:</p>
    <pre>let iPhone = {  
    model: "iPhone X",
    price: "$1500 USD",
    year: 2017
};

let { model: iPhoneModel, price: iPhonePrice, year: iPhoneYear } = iPhone;

console.log(iPhoneModel); // iPhone X
console.log(iPhonePrice); // $1500 USD
console.log(iPhoneYear); // 2017</pre>
    <p>Ngoài ra, chúng ta hoàn toàn có thể sử dụng destructuring assignment để
      lấy ra giá trị của một vài thuộc tính (chứ không nhất thiết lúc nào cũng
      cần lấy ra tất cả giá trị của tất cả thuộc tính):</p>
    <pre><code>let iPhone = {  
    model: "iPhone X",
    price: "$1500 USD",
    year: 2017
};

let { model } = iPhone;

console.log(model); // iPhone</code></pre>
    <h2>Destructuring Array</h2>
    <p>Cú pháp destructuring assignment sử dụng cho array có thay đổi chút ít so
      với object. Thay vì sử dung <code>{}</code> thì chúng ta sẽ sử dụng <code>[]</code>:</p>
    <pre><code>let topSmartPhones2017 = [
    "Samsung Galaxy S8",
    "Samsung Galaxy S8 Plus",
    "iPhone 7 Plus",
    "Samsung Galaxy Note 8",
    "OnePlus 5"
];

let [first, second, third, forth, fifth ] = topSmartPhones2017;

console.log(first); // Samsung Galaxy S8
console.log(second); // Samsung Galaxy S8 Plus
console.log(third); // iPhone 7 Plus
console.log(forth); // Samsung Galaxy Note 8
console.log(fifth); // OnePlus 5</code></pre>
    <p>Giống như destructuring object thì đối với array bạn cũng có thể lấy ra
      giá trị của một vài phần tử thay vì tất cả phần tử:</p>
    <pre><code>let [first, second] = topSmartPhones2017;

console.log(first); // Samsung Galaxy S8
console.log(second); // Samsung Galaxy S8 Plus</code></pre>
    <p>---------------------</p>
    <h1>ES6 import và export</h1>
    <p>ES6 giới thiệu câu lệnh <code>import</code> và <code>export</code> hỗ
      trợ lập trình viên có thể quản lý code theo từng mô-đun.</p>
    <h2>JavaScript Mô-Đun là gì</h2>
    <p>Mô-đun là một phương pháp lập trình mà trong đó các đoạn code liên quan
      được tách ra các phần khác nhau (hay còn gọi là mô-đun).</p>
    <p>Trước ES6 một số thư viện JavaScript hỗ trợ các cách viết code khác nhau
      để hỗ trợ quản lý các mô-đun (module).</p>
    <p>Ví dụ Node.js hỗ trợ sử dụng <code>require()</code> và <code>module.exports()</code>.</p>
    <p>Tạo mô-đun trong file <code>say_hello.js</code>:</p>
    <pre>var sayHello = function(name) {
    console.log("Xin chào! Tên tôi là " + name);
}

module.exports = {
    sayHello: sayHello
};</pre>
    <p>Sử dụng mô-đun tạo ra ở trên trong file <code>hello.js</code>:</p>
    <pre><code>var sayHello = require('./say_hello.js');
sayHello("Peter");</code></pre>
    <p>Sử dụng chương trình Node.js để chạy file <code>hello.js</code>:</p>
    <pre>$ node hello.js
// Xin chào! Tên tôi là Peter</pre>
    <p>Chúng ta có thể sử dụng câu lệnh <code>import</code> và <code>export</code>
      trong phiên bản ES6 để thay thế cho <code>require()</code> và <code>module.export()</code>.</p>
    <p>Lưu ý: Để sử dụng tính năng <code>export</code> và <code>import</code>
      trong ES6 bạn cần sử dụng các trình duyệt hỗ trợ ES6 như Edge, Chrome,
      Firefore và nâng cấp trình duyệt lên phiên bản mới nhất.</p>
    <h2>Câu lệnh export</h2>
    <p>Câu lệnh <code>export</code> dùng để xuất ra một mô-đun:</p>
    <pre>let sayHello = function (name) {
    console.log("Xin chào! Tên tôi là " + name);
}

export { sayHello };</pre>
    <p>Bạn có thể export nhiều mô-đun trong cùng một file:</p>
    <pre>let sayHello = function (name) {
    console.log("Xin chào! Tên tôi là " + name);
}

let sayGoodbye = function () {
    console.log("Chào tạm biệt!");
}

export { sayHello, sayGoodbye };</pre>
    <h2>Câu Lệnh import</h2>
    <p>Câu lệnh <code>import</code> trong ES6 dùng để nhập vào mô-đun từ một
      file cho trước (có thể là từ một thư viện hay mô-đun mà chúng ta tự định
      nghĩa).</p>
    <p>Ví dụ để nhập vào mô-đun <code>sayHello</code> được tạo ra ở ví dụ trên:</p>
    <pre><code>import { sayHello } from 'say_hello.js';</code></pre>
    <p>Đoạn code trên sẽ nhập vào mô-đun <code>sayHello</code> từ tập tin <code>say_hello.js</code>
      và gán giá trị của mô-đun này cho biến <code>sayHello</code>.</p>
    <p>Bạn có thể tuỳ ý đặt tên biến khi import mô-đun <code>sayHello</code> sử
      dụng từ khoá <code>as</code>:</p>
    <pre><code>import { sayHello as sayHelloFunction } from 'say_hello.js';</code></pre>
    <p>Lưu ý: Trong trường hợp có nhiều mô-đun được tạo ra trong cùng một file
      thì bạn có thể tuỳ ý lựa chọn số lượng mô-đun nhập vào chứ không cần thiết
      phải nhập tất cả.</p>
  </body>
</html>
