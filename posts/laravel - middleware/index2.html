<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>Laravel Middleware</title>
  </head>
  <body>
    <h1>Middleware</h1>
    <p>Middleware cung cấp một giải pháp khá tiện ích cho việc filtering HTTP
      các requests vào ứng dụng. Ví dụ, Laravel có chứa một middleware xác thực
      người dùng đăng nhập vào hệ thống. Nếu user chưa đăng nhập, middleware sẽ
      chuyển hướng user tới màn hình đăng nhập. Tuy nhiên, nếu user đã đăng nhập
      rồi, thì middleware sẽ cho phép request được thực hiện tiếp tiến trình xử
      lý vào ứng dụng.</p>
    <p>Tất nhiên, bạn có thể viết thêm middleware để thực hiện nhiều tác vụ nữa
      ngoài kiểm tra đăng nhập vào hệ thống. Một CORS middleware có trách nhiệm
      cho việc thêm các header hợp lý vào trong tất cả các response gửi ra
      ngoài. Một logging middleware có thể ghi log cho tất cả các request tới
      ứng dụng.</p>
    <p>Có vài middleware đã có sẵn trong Laravel framework, bao gồm middlware
      xác thực, CSRF protection. Tất cả được nằm trong thư mục <code>app/Http/Middleware</code>.</p>
    <p><a></a></p>
    <h2>Tạo Middleware</h2>
    <p>Để tạo mới một middleware, sử dụng lệnh <code>make:middleware</code>
      Artisan:</p>
    <pre><code>php artisan make:middleware CheckAge</code></pre>
    <p>Câu lệnh này sẽ tạo ra class <code>CheckAge</code> bên trong thư mục <code>app/Http/Middleware</code>.
      Trong middleware này, chúng ta chỉ cho phép truy cập vào route nếu giá trị
      <code>age</code> lớn hơn 200. Ngược lại, chúng ta sẽ chuyển hướng request
      lại trang <code>home</code> URI.</p>
    <pre><code>&lt;?php

namespace App\Http\Middleware;

use Closure;

class CheckAge
{
    /**
     * Run the request filter.
     *
     * @param    \Illuminate\Http\Request  $request
     * @param    \Closure  $next
     * @return  mixed
     */
    public function handle($request, Closure $next)
    {
        if ($request-&gt;age &lt;= 200) {
            return redirect('home');
        }

        return $next($request);
    }
}</code></pre>
    <p>Như bạn thấy, nếu biến <code>age</code> nhỏ hơn hoặc bằng <code>200</code>,
      middleware sẽ trả về một HTTP tới client; ngược lại, request sẽ được gửi
      tiếp để xử lý. Để truyền request vào sâu hơn trong ứng dụng (cho phép
      middleware "vượt qua"), đơn giản chỉ cần gọi callback <code>$next</code>
      với <code>$request</code>.</p>
    <p>Tốt nhất hãy hình dung như là một chuỗi các "lớp" trên HTTP requests cần
      phải đi qua trước khi nó vào ứng dụng. Mỗi lớp sẽ được kiểm tra request và
      thậm chí có thể hủy từ chối request hoàn toàn.</p>
    <h3>Trước &amp; Sau Middleware</h3>
    <p>Việc middleware chạy trước hay chạy sau một request phụ thuộc vào chính
      nó. Ví dụ, middleware dưới đây sẽ làm một vào tác vụ <strong>trước khi</strong>
      request được chương trình xử lý:</p>
    <pre><code>&lt;?php

namespace App\Http\Middleware;

use Closure;

class BeforeMiddleware
{
    public function handle($request, Closure $next)
    {
        // Perform action

        return $next($request);
    }
}</code></pre>
    <p>Tất nhiên, middleware này sẽ thực hiện việc của nó <strong>sau khi</strong>
      request được xử lý bởi ứng dụng:</p>
    <pre><code>&lt;?php

namespace App\Http\Middleware;

use Closure;

class AfterMiddleware
{
    public function handle($request, Closure $next)
    {
        $response = $next($request);

        // Perform action

        return $response;
    }
}</code></pre>
    <p><a></a></p>
    <h2>Đăng ký Middleware</h2>
    <p><a></a></p>
    <h3>Global Middleware</h3>
    <p>Nếu bạn muốn một middleware có thể thực thi trong mọi HTTP request tới
      ứng dụng của bạn, đơn giản chỉ cần thêm tên class của middleware trong
      thuộc tính <code>$middleware</code> của class <code>app/Http/Kernel.php</code>.</p>
    <p><a></a></p>
    <h3>Gán Middleware vào Routes</h3>
    <p>Nếu bạn muốn gán middleware cho route cụ thể, đầu tiên bạn cần thêm
      middleware đấy vào trong file <code>app/Http/Kernel.php</code>. Mặc định,
      thuộc tính <code>$routeMiddleware</code> sẽ chứa một số class thuộc
      middleware của framework Laravel. Để thêm middleware của bạn, đơn giản chỉ
      là thêm nó vào dach sách và gán từ khóa bạn chọn. Ví dụ:</p>
    <pre><code>// Within App\Http\Kernel Class...

protected $routeMiddleware = [
    'auth' =&gt; \Illuminate\Auth\Middleware\Authenticate::class,
    'auth.basic' =&gt; \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
    'bindings' =&gt; \Illuminate\Routing\Middleware\SubstituteBindings::class,
    'can' =&gt; \Illuminate\Auth\Middleware\Authorize::class,
    'guest' =&gt; \App\Http\Middleware\RedirectIfAuthenticated::class,
    'throttle' =&gt; \Illuminate\Routing\Middleware\ThrottleRequests::class,
];</code></pre>
    <p>Khi middleware đã được định nghĩa trong HTTP kernel, bạn có thể sử dụng
      phương thức <code>middleware</code> gán cho một route:</p>
    <pre><code>Route::get('admin/profile', function() {
    //
})-&gt;middleware('auth');</code></pre>
    <p>Ngoài ra bạn cũng có thể gán nhiều middleware cho một route:</p>
    <pre><code>Route::get('/', function() {
    //
})-&gt;middleware('first', 'second');</code></pre>
    <p>Khi đã gán middleware, bạn cũng có thể sử dụng tên đầy đủ của middleware:</p>
    <pre><code>use App\Http\Middleware\CheckAge;

Route::get('admin/profile', function() {
    //
})-&gt;middleware(CheckAge::class);</code></pre>
    <p><a></a></p>
    <h3>Nhóm Middleware</h3>
    <p>Thỉnh thoảng bạn muốn nhóm một vài middleware lại trong một khóa để thực
      hiện gán vào route dễ dàng hơn. Bạn có thể sử dụng thuộc tính <code>$middlewareGroups</code>
      của HTTP kernel.</p>
    <p>Mặc định, Laravel cung cấp sắp 2 nhóm middleware <code>web</code> và <code>api</code>
      chứa những middleware thường sử dụng mà bạn có thể muốn áp dụng cho web UI
      và API routes:</p>
    <pre><code>/**
 * The application's route middleware groups.
 *
 * @var  array
 */
protected $middlewareGroups = [
    'web' =&gt; [
        \App\Http\Middleware\EncryptCookies::class,
        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
        \Illuminate\Session\Middleware\StartSession::class,
        \Illuminate\View\Middleware\ShareErrorsFromSession::class,
        \App\Http\Middleware\VerifyCsrfToken::class,
        \Illuminate\Routing\Middleware\SubstituteBindings::class,
    ],

    'api' =&gt; [
        'throttle:60,1',
        'auth:api',
    ],
];</code></pre>
    <p>Nhóm middleware được gán vào routes và controller sử dụng cú pháp tương
      tự như với từng middleware. Một lần nữa, nhóm middleware làm đơn giản
      trong việc gán các middleware vào trong một route:</p>
    <pre><code>Route::get('/', function() {
    //
})-&gt;middleware('web');

Route::group(['middleware' =&gt; ['web']], function() {
    //
});</code></pre>
    <p> Chú ý, Nhóm <code>web</code> middleware được tự động áp dụng trong file
      <code>routes/web.php</code> qua <code>RouteServiceProvider</code>.</p>
    <p><a></a></p>
    <h2>Tham số middleware</h2>
    <p>Middleware cũng có thể nhận thêm các tham số truyền vào. Ví dụ, nếu ứng
      dụng của bạn cần xác thực có "role" cụ thể trước khi thực hiện một thao
      tác nào đó, bạn có thể tạo một <code>CheckRole </code>middleware để nhận
      tên của role như một tham số.</p>
    <p>Thêm các tham số middleware sẽ dược truyền vào middleware ngay sau tham
      số <code>$next</code> của hàm handle:</p>
    <pre><code>&lt;?php

namespace App\Http\Middleware;

use Closure;

class CheckRole
{
    /**
     * Handle the incoming request.
     *
     * @param    \Illuminate\Http\Request  $request
     * @param    \Closure  $next
     * @param    string  $role
     * @return  mixed
     */
    public function handle($request, Closure $next, $role)
    {
        if (! $request-&gt;user()-&gt;hasRole($role)) {
            // Redirect...
        }

        return $next($request);
    }
}</code></pre>
    <p>Tham số middleware có thể được khai báo trên route bằng cách phân chia
      tên middleware và tham số bởi dấu <code>:</code>. nhiều thao số thì phân
      chia bởi dấy phẩy:</p>
    <pre><code>Route::put('post/{id}', function($id) {
    //
})-&gt;middleware('role:editor');</code></pre>
    <p><a></a></p>
    <h2>Terminable Middleware</h2>
    <p>Thỉnh thoảng một middleware có thể cần thực hiện sau khi HTTP response đã
      được gửi xong cho trình duyệt. Ví dụ, "session" middleware đi kèm với
      Laravel cung cấp dữ liệu session cho storage sau khi response được gửi tới
      trình duyệt. Nếu bạn định nghĩa một <code>terminate</code> vào trong
      middleware, nó sẽ tự động được gọi sau khi response được gửi tới trình
      duyệt.</p>
    <pre><code>&lt;?php

namespace Illuminate\Session\Middleware;

use Closure;

class StartSession
{
    public function handle($request, Closure $next)
    {
        return $next($request);
    }

    public function terminate($request, $response)
    {
        // Store the session data...
    }
}</code></pre>
    <p>Hàm <code>terminate</code> sẽ nhận cả request và response. Khi bạn đã
      định nghĩa terminable middleware, bạ phải thêm nó vào trong danh sách
      global middleware trong HTTP kernel.</p>
    <p>Khi gọi hàm <code>terminate</code> trong middleware, Laravel sẽ thực
      hiện giải quyết trường hợp mới cho middleware từ <a href="https://giaphiep.com/docs/5.3/container">service
        container</a>. Nếu bạn muốn sử dụng cùng một trường hợp khi mà hàm <code>handle</code>và
      hàm <code>terminate</code> được gọi, đăng ký middleware vào trong
      container sử dụng hàm <code>singleton</code>.</p>
    <p> Nguồn: <a href="https://laravel.com/docs/5.3/middleware">https://laravel.com/docs/5.3/middleware</a>
    </p>
  </body>
</html>
