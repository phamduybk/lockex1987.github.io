<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <title></title>
    <link rel="icon" href="../../images/favicon.png">
    <link rel="stylesheet" href="../../css/style.css">
  </head>
  <body>
    <article>
      <h2>Unit Testing phần 2: Phương thức assertion và data provider</h2>
      <p>Trong phần trước chúng ta đã cài đặt và cấu hình PHPUnit cho một dự án,
        chúng ta cũng đã tìm hiểu vài quy ước mà PHPUnit yêu cầu, sau đó tạo ra
        một ví dụ kiểm thử đầu tiên đơn giản và không hữu dụng lắm.</p>
      <h3>Assertion</h3>
      PHPUnit có khoảng 90 phương thức assertion. Chúng ta không cần phải nhớ
      tất cả, các assertion có mở đầu là assert: $this-&gt;assert*. Một số các
      assertion hay dùng <code>assertArrayHasKey()</code>, <code>assertEquals()</code>,
      <code>assertFalse()</code>, <code>assertSame()</code> và <code>assertTrue()</code>.
      Các phương thức assertion chỉ là các phương thức thông thường, nó trả về
      true hoặc false tùy thuộc vào kết quả các đoạn code mà bạn truyền vào. Nếu
      bạn không tìm thấy assertion nào phù hợp, bạn có thể tạo ra một assertion.
      Không có gì quá phức tạp, nó chỉ đơn giản là tạo ra một phương thức trong
      class kiểm thử. Chúng ta sẽ quay lại vấn đề này trong các bài sau.
      <h3>Ví dụ kiểm thử thứ hai</h3>
      <p>Chúng ta sẽ thực hiện một ví dụ kiểm thử thứ hai hữu ích hơn trong thực
        tế. Trong tối ưu bộ máy tìm kiếm (SEO) như Google, Bing... các đường dẫn
        trang web nên sử dụng dấu gạch ngang để phân cách các từ, do vậy cần có
        một phương thức chuyển từ dòng tiêu đề bài viết sang thành nội dung
        đường dẫn bằng cách bỏ dấu đi và phân cách bằng dấu gạch ngang. Ví dụ
        bài viết "<em>Unit Testing với PHPUnit</em>" sẽ được chuyển thành "<em>unit-testing-voi-phpunit</em>".
        Chúng ta cùng tạo ra một Class URL trong app để xử lý các vấn đề về URL:</p>
      <pre>&lt;?php
namespace App;<br>
class URL
{
    public function sluggify($string, $separator = '-', $maxLength = 96)
    {
        $title = iconv('UTF-8', 'ASCII//TRANSLIT', $string);
        $title = preg_replace("%[^-/+|\w ]%", '', $title);
        $title = strtolower(trim(substr($title, 0, $maxLength), '-'));
        $title = preg_replace("/[\/_|+ -]+/", $separator, $title);
        return $title;
    }
}</pre>
      <p>Sau khi tạo ra được phương thức <code>sluggify()</code> chúng ta muốn kiểm thử xem
        phương thức này hoạt động có đúng như mong muốn hay không? Có thể có
        những lỗi tiềm ẩn không lường trước được. Để kiểm thử phương thức chúng
        ta sẽ tạo ra một file test <code>./tests/URLTest.php</code> với nội dung như sau:</p>
      <pre>&lt;?php
namespace Test;<br><br>use PHPUnit\Framework\TestCase;<br>
class URLTest extends TestCase
{
    //
}</pre>
      <p>Thử chạy PHPUnit xem đã có phát hiện gì chưa?</p>
      <pre>$ vendor\bin\phpunit
PHPUnit 5.7.21 by Sebastian Bergmann and contributors.

.W                                                                  2 / 2 (100%)

Time: 60 ms, Memory: 2.50MB

There was 1 warning:

1) Warning
No tests found in class "app\Test\URLTest".

WARNINGS!
Tests: 2, Assertions: 1, Warnings: 1.</pre>
      <p>Như vậy là đã có hai kiểm thử đã được thực hiện, trong đó có 1 xác nhận
        là kiểm thử thành công và 1 cảnh báo. Nguyên nhân cảnh báo là do PHPUnit
        không tìm thấy phương thức test nào trong file <code>tests\URLTest.php</code>. Tiếp
        theo chúng ta sẽ đưa vào phương thức test cho <code>URL::sluggify()</code> để xác
        nhận rằng phương thức này sẽ trả về một kết quả như mong muốn.</p>
      <pre>&lt;?php
namespace Test;

use PHPUnit\Framework\TestCase;

class URLTest extends TestCase
{
    public function testSluggifyReturnsSluggifiedString()
    {
        // Kiểm tra phương thức sluggify có trả về một chuỗi không dấu và phân cách bằng dấu gạch ngang
    }
}</pre>
      <p>Khi chạy lại PHPUnit chúng ta đã thấy không còn cảnh báo. Tuy nhiên
        trong phương thức kiểm thử chúng ta chưa thực hiện gì, tiếp theo sửa đổi
        nội dung phương thức <code>testSluggifyReturnsSluggifiedString()</code>:</p>
      <pre>&lt;?php
namespace Test;
use app\URL;
class URLTest extends \PHPUnit_Framework_TestCase
{
    public function testSluggifyReturnsSluggifiedString()
    {
        $originalString = 'Đây là chuỗi cần được xử lý dấu và gạch ngang';
        $expectedResult = 'day-la-chuoi-can-duoc-xu-ly-dau-va-gach-ngang';
        $url = new URL();
        $result = $url-&gt;sluggify($originalString);
        $this-&gt;assertEquals($expectedResult, $result);
    }
}</pre>
      <p>Phương thức <code>testSluggifyReturnsSluggifiedString()</code> sẽ kiểm tra một chuỗi
        "<em>Đây là chuỗi cần được xử lý dấu và gạch ngang</em>" xem sau khi qua phương
        thức <code>URL::sluggify()</code> có ra kết quả như mong đợi là
        "<em>day-la-chuoi-can-duoc-xu-ly-dau-va-gach-ngang</em>" hay không? Chúng ta chạy
        PHPUnit:</p>
      <pre>$ vendor\bin\phpunit
PHPUnit 5.7.21 by Sebastian Bergmann and contributors.

..                                                                  2 / 2 (100%)

Time: 63 ms, Memory: 2.25MB

OK (2 tests, 2 assertions)</pre>
      <p>Như vậy cả hai kiểm thử (ví dụ 1 và ví dụ 2) đều thành công với 2 xác
        nhận. Trường hợp test ở trên chúng ta mới chỉ kiểm tra các chuỗi chứa ký
        tự thông thường, trong một kịch bản test đầy đủ, chúng ta có thể test cả
        các trường hợp khác như chuỗi chứa các ký tự số, ký tự đặc biệt... Điều
        chỉnh lại code của file test <code>URLTest.php</code> như sau:</p>
      <pre>    public function testSluggifyReturnsExpectedForStringsContainingNumbers()
    {
        // Phương thức này kiểm thử với một chuỗi có chữ số
        $originalString = 'Unit testing phần2 PHPUnit có 100phương thức xác nhận';
        $expectedResult = 'unit-testing-phan2-phpunit-co-100phuong-thuc-xac-nhan';
        $url = new URL();
        $result = $url-&gt;sluggify($originalString);
        $this-&gt;assertEquals($expectedResult, $result);
    }

    public function testSluggifyReturnsExpectedForStringsContainingSpecialCharacters()
    {
        // Phương thức này kiểm thử với một chuỗi có ký tự đặc biệt
        $originalString = 'Unit testing - Phần 2: Assertion() và dataProvider';
        $expectedResult = 'unit-testing-phan-2-assertion-va-dataprovider';
        $url = new URL();
        $result = $url-&gt;sluggify($originalString);
        $this-&gt;assertEquals($expectedResult, $result);
    }

    public function testSluggifyReturnsExpectedForEmptyStrings()
    {
        // Kiểm thử với chuỗi đầu vào là rỗng
        $originalString = '';
        $expectedResult = '';
        $url = new URL();
        $result = $url-&gt;sluggify($originalString);
        $this-&gt;assertEquals($expectedResult, $result);
    }
</pre>
      <p>Trong nội dung file test tiếp theo này, chúng ta đã thêm vào các phương
        thức test mới:</p><ul><li><code>testSluggifyReturnsExpectedForStringsContainingNumbers</code>
        để kiểm tra xem <code>URL::sluggify()</code> có hoạt động tốt với một chuỗi có chứa
        số.</li><li><code>testSluggifyReturnsExpectedForStringsContainingSpecialCharacters</code>
          kiểm tra xem <code>URL::sluggify()</code> có hoạt động tốt với ký tự đặc biệt
          không.</li><li><code>testSluggifyReturnsExpectedForEmptyStrings</code> kiểm tra xem
          <code>URL::sluggify()</code> hoạt động tốt chuỗi đầu vào rỗng không.</li><li>...</li></ul><ul>
      </ul>
      Thực hiện chạy test với PHPUnit:
      <pre>$ vendor\bin\phpunit
PHPUnit 5.7.21 by Sebastian Bergmann and contributors.

......                                                              6 / 6 (100%)

Time: 71 ms, Memory: 2.25MB

OK (6 tests, 6 assertions)</pre>
      <p>Như vậy chúng ta thấy có 6 trường hợp kiểm thử được thực hiện và kết
        quả đều là tốt. Tuy nhiên, chúng thấy có một vấn đề là có quá nhiều
        phương thức kiểm thử được viết ra, cảm giác như có cái gì đó được lặp đi
        lặp lại. Nếu như <code>URL::sluggify()</code> có hàng trăm trường hợp cần test mà
        viết như thế này thì thật là không ổn. PHPUnit cũng đã tính đến trường
        hợp này, với dataProvider, các phương thức kiểm thử sẽ được cô đọng lại.</p>
      <h3>Phương thức cung cấp dữ liệu</h3>
      <p>Như ở trong ví dụ trên chúng ta thấy có rất nhiều các phương thức kiểm
        thử, PHPUnit đã đưa ra phương thức cung cấp dữ liệu (data provider) giúp
        cho các phương thức kiểm thử này có thể được viết lại rất ngắn gọn.
        Chúng ta sẽ cùng tìm hiểu các phương thức này.</p><p>Trước khi đi vào tìm hiểu
        data provider chúng ta tìm hiểu về annotation vì nó được sử dụng để các
        phương thức kiểm thử nhận biết được phương thức nào sẽ cung cấp dữ liệu
        cho nó. Annotation là các thẻ được sử dụng trong một khối chú thích giúp
        tăng thêm thông tin cho mã nguồn. Ngôn ngữ PHP không có core engine cho
        annotation. Các class trong PHPUnit sử dụng annotation để có thêm các
        thông tin, nó có thể dùng trong lúc chạy để thiết lập các hành vi. Một
        khối chú thích trong PHP được bắt đầu bằng <code>/**</code> và kết thúc bằng <code>*/</code>.</p>
      <pre>/**
 * @annotationName Annotation value
 */
public function testFoo()
{
    //
}</pre>
      <p>Chúng ta quay lại với phương thức cung cấp dữ liệu data provider. Như
        đã nói ở trên có thể dùng nó để cung cấp dữ liệu kiểm thử cho một phương
        thức kiểm thử. Nó sử dụng annotation <code>@dataProvider</code> để nhận
        biết là nó thuộc về phương thức kiểm thử nào. Như vậy chúng ta không cần
        tạo ra nhiều các phương thức kiểm khác nhau, thay vào đó chúng ta chỉ
        cần tạo ra một phương thức với tham số là một data provider.</p>
      <pre>&lt;?php
namespace Test;
use App\URL;

class URLTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @param string $originalString Chuỗi cần xử lý
     * @param string $expectedResult Kết quả mong đợi
     *
     * @dataProvider providerTestSluggifyReturnsSluggifiedString
     */
    public function testSluggifyReturnsSluggifiedString($originalString, $expectedResult)
    {
        $url = new URL();
        $result = $url-&gt;sluggify($originalString);
        $this-&gt;assertEquals($expectedResult, $result);
    }

    public function providerTestSluggifyReturnsSluggifiedString()
    {
        return array(
            array('Đây là chuỗi cần được xử lý dấu và gạch ngang', 'day-la-chuoi-can-duoc-xu-ly-dau-va-gach-ngang'),
            array('ĐÂY LÀ CHUỖI CẦN XỬ LÝ DẤU VÀ GẠCH NGANG', 'day-la-chuoi-can-duoc-xu-ly-dau-va-gach-ngang'),
            array('Unit testing phần2 PHPUnit có 100phương thức xác nhận', 'unit-testing-phan2-phpunit-co-100phuong-thuc-xac-nhan'),
            array('Unit testing - "Phần 2": Assertion() và dataProvider!', 'unit-testing-phan-2-assertion-va-dataprovider'),
            array('', ''),
        );
    }
}</pre>
      <p>Bạn thấy đấy, thay vì rất nhiều các phương thức kiểm thử, chúng ta đã
        có một phương thức kiểm thử duy nhất và một phương thức cung cấp dữ liệu
        để kiểm thử và được mapping thông qua annotation <code>@dataProvider</code>. Kết quả
        khi thực hiện kiểm thử với PHPUnit:</p>
      <pre>$ vendor\bin\phpunit
PHPUnit 5.7.21 by Sebastian Bergmann and contributors.

.......                                                             7 / 7 (100%)

Time: 79 ms, Memory: 2.50MB

OK (7 tests, 7 assertions)</pre>
      <p>Như vậy, thay thì phải viết 6 phương thức kiểm thử chúng ta sử dụng
        Data Provider giúp cho code được gọn gàng hơn.</p>
      <h3>Kết luận</h3>
      <p>Phần 2 đã kết thúc với những kiến thức giúp bạn có thể viết các chương
        trình kiểm thử ngắn gọn nhưng rất đầy đủ các trường hợp cần test. Chúng
        ta đã đi qua các vấn đề cơ bản nhất của Unit testing trong PHP, trong
        phần tiếp theo chúng ta sẽ đi sâu hơn vào cách kiểm thử các thành phần
        của một class với các phạm vi truy cập thành phần khác nhau, cuối cùng
        chúng ta sẽ cùng tìm hiểu cách thức sinh ra các báo cáo kiểm thử (test
        report) giúp công tác quản lý tốt hơn.</p>
      <p></p>
    </article>
    <script src="../../js/docs.js"></script>
  

</body></html>